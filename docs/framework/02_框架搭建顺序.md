# Drun 框架搭建顺序

## 一、搭建顺序概览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          框架搭建顺序 (8个阶段)                               │
└─────────────────────────────────────────────────────────────────────────────┘

阶段1: 数据模型层 ──▶ 阶段2: 基础工具层 ──▶ 阶段3: 加载器层
         │                    │                    │
         ▼                    ▼                    ▼
    [无依赖]            [依赖: 无]          [依赖: models]


阶段4: 模板引擎 ──▶ 阶段5: HTTP引擎 ──▶ 阶段6: 执行器层
         │                    │                    │
         ▼                    ▼                    ▼
  [依赖: utils]        [依赖: 无]       [依赖: 1-5全部]


阶段7: 报告层 ──▶ 阶段8: CLI入口
         │                    │
         ▼                    ▼
  [依赖: models]      [依赖: 1-7全部]
```

## 二、各阶段详细说明

### 阶段1: 数据模型层 (models/)

**搭建顺序**：
```
① validators.py  (无依赖)
        │
        ▼
② request.py     (无依赖)
        │
        ▼
③ config.py      (无依赖)
        │
        ▼
④ step.py        (依赖: validators, request)
        │
        ▼
⑤ case.py        (依赖: config, step)
        │
        ▼
⑥ report.py      (依赖: 无，独立模块)
```

**validators.py 核心代码示例**：
```python
from pydantic import BaseModel
from typing import Any, List

class Validator(BaseModel):
    check: str           # 检查项，如 "status_code" 或 "$.data.id"
    comparator: str      # 比较器，如 "eq", "contains", "regex"
    expect: Any          # 期望值

def normalize_validators(raw: List[dict]) -> List[Validator]:
    """将 YAML 简写格式转换为 Validator 对象"""
    # { eq: [status_code, 200] } -> Validator(check="status_code", comparator="eq", expect=200)
```

**step.py 核心代码示例**：
```python
from pydantic import BaseModel, model_validator
from typing import Optional, List, Dict, Any

class Step(BaseModel):
    name: str
    variables: Dict[str, Any] = {}
    request: Optional[StepRequest] = None   # HTTP 请求
    invoke: Optional[str] = None            # 调用其他用例
    extract: Dict[str, str] = {}            # 数据提取
    validators: List[Validator] = []        # 断言列表
    setup_hooks: List[str] = []             # 前置钩子
    teardown_hooks: List[str] = []          # 后置钩子
    skip: Optional[str | bool] = None       # 跳过条件
    retry: int = 0                          # 重试次数
    
    @model_validator(mode="after")
    def check_request_or_invoke(self):
        """确保 request 和 invoke 二选一"""
        if self.request and self.invoke:
            raise ValueError("不能同时有 request 和 invoke")
        if not self.request and not self.invoke:
            raise ValueError("必须有 request 或 invoke")
        return self
```

### 阶段2: 基础工具层 (utils/)

**搭建顺序**：
```
① errors.py      (自定义异常)
        │
        ▼
② logging.py     (日志配置)
        │
        ▼
③ mask.py        (敏感信息脱敏)
        │
        ▼
④ 其他工具文件   (按需添加)
```

**errors.py 核心代码**：
```python
class LoadError(Exception):
    """YAML 加载错误"""
    pass

class ValidationError(Exception):
    """断言验证错误"""
    pass
```

### 阶段3: 加载器层 (loader/)

**搭建顺序**：
```
① env.py          (环境变量加载，无依赖)
        │
        ▼
② hooks.py        (钩子加载，无依赖)
        │
        ▼
③ yaml_loader.py  (YAML解析，依赖 models)
        │
        ▼
④ collector.py    (文件发现，依赖 yaml_loader)
```

**env.py 核心逻辑**：
```python
def load_environment(env_name: str, env_file: str) -> Dict[str, Any]:
    """
    加载环境变量
    
    优先级 (从低到高):
    1. .env 文件
    2. .env.{env_name} 文件
    3. 系统环境变量
    """
```

**collector.py 核心逻辑**：
```python
def discover(paths: List[str]) -> List[Path]:
    """
    发现测试文件
    
    规则:
    1. 后缀: .yaml 或 .yml
    2. 位置: testcases/ 或 testsuites/ 目录
    3. 命名: test_*.yaml 或 suite_*.yaml
    """

def match_tags(tags: List[str], expr: str) -> bool:
    """
    标签匹配，支持布尔表达式
    
    示例:
    - "smoke"           -> 包含 smoke 标签
    - "smoke and api"   -> 同时包含 smoke 和 api
    - "smoke or e2e"    -> 包含 smoke 或 e2e
    - "not slow"        -> 不包含 slow
    """
```

### 阶段4: 模板引擎层 (templating/)

**搭建顺序**：
```
① builtins.py     (内置函数，无依赖)
        │
        ▼
② context.py      (变量上下文，无依赖)
        │
        ▼
③ engine.py       (模板引擎，依赖 builtins)
```

**builtins.py 内置函数列表**：
```python
BUILTINS = {
    # 时间/标识
    "now": now,              # 当前时间 ISO 格式
    "uuid": uuid,            # UUID v4
    "random_int": random_int, # 随机整数
    
    # 编码/加密
    "base64_encode": base64_encode,
    "hmac_sha256": hmac_sha256,
    
    # 类型转换
    "to_str": to_str,
    "to_int": to_int,
    
    # Mock 数据 (Faker)
    "fake_name": fake_name,
    "fake_email": fake_email,
    "fake_phone_number": fake_phone_number,
    "fake_address": fake_address,
    "fake_city": fake_city,
    "fake_company": fake_company,
    "fake_url": fake_url,
    "fake_ipv4": fake_ipv4,
    "fake_user_agent": fake_user_agent,
    "fake_date": fake_date,
    "fake_text": fake_text,
}
```

**engine.py 核心逻辑**：
```python
class TemplateEngine:
    def render_value(self, value, variables, functions=None, envmap=None):
        """
        渲染模板值
        
        支持的语法:
        1. $variable        -> 简单变量
        2. ${variable}      -> 变量表达式
        3. ${func()}        -> 函数调用
        4. ${func(arg)}     -> 带参数函数
        5. ${ENV(NAME)}     -> 环境变量
        6. ${ENV(NAME,default)} -> 带默认值环境变量
        """
```

### 阶段5: HTTP引擎层 (engine/)

**核心文件**: `http.py`

```python
import httpx
from typing import Dict, Any

class HTTPClient:
    def __init__(self, base_url: str, timeout: float = 30.0, 
                 verify: bool = True, headers: Dict = None):
        self.base_url = base_url
        self.client = httpx.Client(
            base_url=base_url,
            timeout=timeout,
            verify=verify,
            headers=headers or {}
        )
    
    def request(self, req: Dict[str, Any]) -> Dict[str, Any]:
        """
        发送 HTTP 请求
        
        参数 req 结构:
        {
            "method": "POST",
            "path": "/api/login",
            "headers": {...},
            "params": {...},
            "body": {...},      # JSON 请求体
            "data": {...},      # Form 请求体
            "files": {...},     # 文件上传
            "auth": {...},      # 认证信息
            "timeout": 10.0,
            "stream": False     # 是否流式响应
        }
        
        返回:
        {
            "status_code": 200,
            "headers": {...},
            "body": {...},      # 响应体 (JSON 或文本)
            "elapsed_ms": 123.4,
            "url": "https://...",
            "method": "POST"
        }
        """
```

### 阶段6: 执行器层 (runner/)

**搭建顺序**：
```
① extractors.py   (数据提取，依赖 jmespath)
        │
        ▼
② assertions.py   (断言比较，无依赖)
        │
        ▼
③ runner.py       (执行引擎，依赖所有模块)
```

**assertions.py 断言函数**：
```python
# 19 种断言类型
OPS = {
    # 相等性
    "eq": lambda a, b: a == b,
    "ne": lambda a, b: a != b,
    
    # 数值比较
    "lt": lambda a, b: a < b,
    "le": lambda a, b: a <= b,
    "gt": lambda a, b: a > b,
    "ge": lambda a, b: a >= b,
    
    # 字符串
    "contains": lambda a, b: b in a,
    "not_contains": lambda a, b: b not in a,
    "regex": lambda a, b: bool(re.search(b, str(a))),
    
    # 集合
    "in": lambda a, b: a in b,
    "not_in": lambda a, b: a not in b,
    "contains_all": ...,
    "match_regex_all": ...,
    
    # 长度
    "len_eq": lambda a, b: len(a) == b,
    "len_gt": lambda a, b: len(a) > b,
    "len_ge": lambda a, b: len(a) >= b,
    "len_lt": lambda a, b: len(a) < b,
    "len_le": lambda a, b: len(a) <= b,
    
    # 存在性
    "exists": lambda a, b: (a is not None) == b,
}
```

### 阶段7: 报告层 (reporter/)

**最小实现**: `html_reporter.py`

```python
def write_html(report: RunReport, path: str, environment: str = None):
    """
    生成 HTML 报告
    
    特点:
    1. 单文件，无外部依赖
    2. 包含请求/响应详情
    3. 断言结果高亮
    4. 响应式设计
    """
```

### 阶段8: CLI入口 (cli.py)

整合所有模块，实现命令行接口。

## 三、环境配置详细步骤

### 3.1 使用 uv (推荐)

```bash
# 1. 安装 uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# 2. 创建项目目录
mkdir drun && cd drun

# 3. 创建虚拟环境
uv venv
source .venv/bin/activate  # Linux/macOS
# .venv\Scripts\activate   # Windows

# 4. 安装核心依赖
uv pip install httpx pydantic jmespath PyYAML rich typer Faker

# 5. 安装可选依赖 (按需)
uv pip install fastapi uvicorn  # Web 服务器
uv pip install pymysql          # MySQL 支持

# 6. 开发模式安装
pip install -e .
```

### 3.2 pyproject.toml 配置

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "drun"
version = "1.0.0"
description = "HTTP API 测试框架"
requires-python = ">=3.10"
dependencies = [
    "httpx>=0.27",      # HTTP 客户端
    "pydantic>=2.6",    # 数据校验
    "jmespath>=1.0",    # JSON 路径查询
    "PyYAML>=6.0",      # YAML 解析
    "rich>=13.7",       # 终端美化
    "typer>=0.12",      # CLI 框架
    "Faker>=24.0",      # Mock 数据
]

[project.optional-dependencies]
server = ["fastapi>=0.104", "uvicorn>=0.24"]
mysql = ["pymysql"]
all = ["fastapi>=0.104", "uvicorn>=0.24", "pymysql"]

[project.scripts]
drun = "drun.cli:app"

[tool.setuptools.packages.find]
include = ["drun*"]
```

### 3.3 依赖说明

| 依赖 | 版本 | 作用 | 必需 |
|------|------|------|------|
| httpx | >=0.27 | 现代 HTTP 客户端，支持同步/异步 | ✅ |
| pydantic | >=2.6 | 数据校验和模型定义 | ✅ |
| jmespath | >=1.0 | JSON 路径查询表达式 | ✅ |
| PyYAML | >=6.0 | YAML 文件解析 | ✅ |
| rich | >=13.7 | 终端美化输出 | ✅ |
| typer | >=0.12 | CLI 命令行框架 | ✅ |
| Faker | >=24.0 | Mock 数据生成 | 推荐 |
| fastapi | >=0.104 | Web 报告服务器 | 可选 |
| uvicorn | >=0.24 | ASGI 服务器 | 可选 |
| pymysql | - | MySQL 数据库支持 | 可选 |
