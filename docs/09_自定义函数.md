# 自定义函数

通过 `drun_hooks.py` 文件，可以使用 Python 编写自定义函数，扩展 Drun 的能力。

## 文件位置

钩子文件必须命名为 `drun_hooks.py`，放在项目根目录：

```
my-project/
├── drun_hooks.py      # 钩子函数文件
├── testcases/
├── testsuites/
└── .env
```

Drun 会从测试文件位置向上搜索，找到第一个 `drun_hooks.py` 并加载。

## 函数类型

### 1. 普通函数

可在模板中直接调用的函数。

```python
# drun_hooks.py
def get_timestamp():
    """获取当前时间戳"""
    import time
    return str(int(time.time()))

def format_date(fmt="%Y-%m-%d"):
    """格式化当前日期"""
    from datetime import datetime
    return datetime.now().strftime(fmt)

def generate_order_no():
    """生成订单号"""
    import time
    import random
    return f"ORD{int(time.time())}{random.randint(1000, 9999)}"
```

调用方式：

```yaml
steps:
  - name: 创建订单
    request:
      method: POST
      path: /api/orders
      body:
        orderNo: ${generate_order_no()}
        timestamp: ${get_timestamp()}
        date: ${format_date(%Y-%m-%d %H:%M:%S)}
```

### 2. Setup Hooks（前置钩子）

在请求发送前执行，可修改请求或添加变量。

```python
# drun_hooks.py
import hmac
import hashlib
import time
import json

def setup_hook_sign_request(hook_ctx):
    """请求签名"""
    secret = hook_ctx['env'].get('API_SECRET', '')
    timestamp = str(int(time.time()))
    
    # 获取请求体
    body = hook_ctx.get('body', {})
    body_str = json.dumps(body, sort_keys=True) if body else ''
    
    # 计算签名
    message = f"{timestamp}:{body_str}"
    signature = hmac.new(
        secret.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # 返回要添加的变量
    return {
        'timestamp': timestamp,
        'signature': signature
    }

def setup_hook_add_trace_id(hook_ctx):
    """添加追踪 ID"""
    import uuid
    return {
        'traceId': str(uuid.uuid4())
    }
```

调用方式：

```yaml
steps:
  - name: 签名请求
    setup_hooks:
      - ${setup_hook_sign_request($request)}
    request:
      method: POST
      path: /api/secure
      headers:
        X-Timestamp: $timestamp
        X-Signature: $signature
        X-Trace-Id: $traceId
      body:
        data: value
```

### 3. Teardown Hooks（后置钩子）

在请求完成后执行，可用于清理或日志记录。

```python
# drun_hooks.py
def teardown_hook_log_response(hook_ctx):
    """记录响应日志"""
    response = hook_ctx.get('response', {})
    step_name = hook_ctx.get('step_name', 'Unknown')
    status_code = response.get('status_code', 0)
    
    print(f"[LOG] Step: {step_name}, Status: {status_code}")

def teardown_hook_cleanup(hook_ctx):
    """清理测试数据"""
    response = hook_ctx.get('response', {})
    # 如果创建了资源，可以在这里清理
    resource_id = response.get('body', {}).get('data', {}).get('id')
    if resource_id:
        print(f"[CLEANUP] Resource ID: {resource_id}")
```

调用方式：

```yaml
steps:
  - name: 创建资源
    request:
      method: POST
      path: /api/resources
    teardown_hooks:
      - ${teardown_hook_log_response()}
      - ${teardown_hook_cleanup()}
```

## hook_ctx 上下文

钩子函数接收 `hook_ctx` 字典参数，包含以下内容：

### Setup Hook 上下文

| 字段 | 类型 | 说明 |
|------|------|------|
| `request` | dict | 请求配置 |
| `method` | string | HTTP 方法 |
| `path` | string | 请求路径 |
| `headers` | dict | 请求头 |
| `body` | any | 请求体 |
| `params` | dict | 查询参数 |
| `variables` | dict | 当前变量上下文 |
| `env` | dict | 环境变量 |
| `step_name` | string | 步骤名称 |
| `case_name` | string | 用例名称 |

### Teardown Hook 上下文

| 字段 | 类型 | 说明 |
|------|------|------|
| `response` | dict | 响应结果 |
| `status_code` | int | 状态码 |
| `headers` | dict | 响应头 |
| `body` | any | 响应体 |
| `elapsed_ms` | float | 响应时间 |
| `variables` | dict | 当前变量上下文 |
| `env` | dict | 环境变量 |
| `step_name` | string | 步骤名称 |
| `case_name` | string | 用例名称 |

## 常用场景示例

### 1. API 签名

```python
import hmac
import hashlib
import time
import json

def setup_hook_api_sign(hook_ctx):
    """通用 API 签名"""
    app_key = hook_ctx['env'].get('APP_KEY', '')
    app_secret = hook_ctx['env'].get('APP_SECRET', '')
    timestamp = str(int(time.time() * 1000))
    
    # 构造签名字符串
    method = hook_ctx.get('method', 'GET').upper()
    path = hook_ctx.get('path', '')
    body = hook_ctx.get('body', {})
    body_str = json.dumps(body, sort_keys=True, separators=(',', ':')) if body else ''
    
    sign_str = f"{method}\n{path}\n{timestamp}\n{body_str}"
    
    # 计算签名
    signature = hmac.new(
        app_secret.encode(),
        sign_str.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return {
        'appKey': app_key,
        'timestamp': timestamp,
        'sign': signature
    }
```

### 2. Token 刷新

```python
import httpx

def setup_hook_refresh_token(hook_ctx):
    """自动刷新 Token"""
    env = hook_ctx['env']
    refresh_token = env.get('REFRESH_TOKEN', '')
    base_url = env.get('BASE_URL', '')
    
    if not refresh_token:
        return {}
    
    # 调用刷新接口
    response = httpx.post(
        f"{base_url}/api/auth/refresh",
        json={"refresh_token": refresh_token}
    )
    
    if response.status_code == 200:
        data = response.json()
        return {
            'accessToken': data.get('data', {}).get('access_token', '')
        }
    
    return {}
```

### 3. 数据库断言

```python
import pymysql

def setup_hook_query_db(hook_ctx, sql):
    """查询数据库"""
    env = hook_ctx['env']
    
    conn = pymysql.connect(
        host=env.get('DB_HOST', 'localhost'),
        user=env.get('DB_USER', 'root'),
        password=env.get('DB_PASSWORD', ''),
        database=env.get('DB_NAME', 'test')
    )
    
    try:
        cursor = conn.cursor()
        cursor.execute(sql)
        result = cursor.fetchone()
        return {'dbResult': result[0] if result else None}
    finally:
        conn.close()
```

使用：

```yaml
steps:
  - name: 验证数据库
    setup_hooks:
      - ${setup_hook_query_db(SELECT status FROM orders WHERE id = 123)}
    request:
      method: GET
      path: /api/orders/123
    validate:
      - eq: [$.data.status, $dbResult]
```

### 4. 动态生成测试数据

```python
from faker import Faker

fake = Faker('zh_CN')

def generate_user_data():
    """生成随机用户数据"""
    return {
        'username': fake.user_name(),
        'email': fake.email(),
        'phone': fake.phone_number(),
        'address': fake.address()
    }
```

### 5. 加密解密

```python
import base64
from cryptography.fernet import Fernet

def encrypt_data(hook_ctx, data):
    """加密数据"""
    key = hook_ctx['env'].get('ENCRYPT_KEY', '')
    f = Fernet(key.encode())
    encrypted = f.encrypt(data.encode())
    return {'encryptedData': encrypted.decode()}

def decrypt_data(hook_ctx, data):
    """解密数据"""
    key = hook_ctx['env'].get('ENCRYPT_KEY', '')
    f = Fernet(key.encode())
    decrypted = f.decrypt(data.encode())
    return {'decryptedData': decrypted.decode()}
```

## 注意事项

1. **函数名唯一**：确保函数名不与内置函数冲突
2. **异常处理**：建议在函数内处理异常，避免中断测试
3. **返回值**：Setup hooks 返回的字典会合并到变量上下文
4. **依赖管理**：确保 hooks 中使用的依赖已安装
5. **性能考虑**：避免在 hooks 中执行耗时操作
